<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self';">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  <title>Military Force Calculator</title>
  <link rel="stylesheet" href="../src/styles/styles.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: white;
    }

    .calculator {
      background: #16213e;
      padding: 30px;
      border-radius: 15px;
      border: 1px solid #333;
    }

    h1 {
      text-align: center;
      color: #64b5f6;
      margin-bottom: 30px;
    }

    .section {
      background: #0f3460;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .input-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .input-with-button {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }

    .input-with-button input {
      flex: 1;
      padding: 10px;
      border: 1px solid #555;
      border-radius: 5px;
      background: #2a2a3e;
      color: white;
      font-size: 16px;
    }

    .copy-button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.3s, opacity 0.2s, transform 0.05s;
    }

    .copy-button:hover {
      background: #2563eb;
    }

    .copy-button.success {
      background: #10b981;
    }

    .copy-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .remaining-display {
      background: #4caf50;
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      font-weight: bold;
      margin: 15px 0;
    }

    .troop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }

    .troop-card {
      background: #1e3a8a;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #3b82f6;
    }

    .troop-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .troop-header h4 {
      margin: 0;
      color: white;
    }

    .percentage-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }


    .percentage-row input {
      width: 60px;
      padding: 5px;
      border: 1px solid #555;
      border-radius: 3px;
      background: #2a2a3e;
      color: white;
      text-align: center;
    }

    .troop-result {
      background: #374151;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s;
      user-select: none;
    }

    .troop-result:hover {
      background: #4b5563;
    }

    .troop-result.copied {
      background: #10b981;
    }

    .percentage-status {
      text-align: center;
      padding: 10px;
      border-radius: 5px;
      font-weight: bold;
      margin-top: 15px;
    }

    .percentage-valid {
      background: #065f46;
      color: #10b981;
    }

    .percentage-invalid {
      background: #7f1d1d;
      color: #ef4444;
    }

    .summary {
      background: #374151;
      padding: 20px;
      border-radius: 10px;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid #4b5563;
    }

    .disabled {
      opacity: 0.5;
    }

    h3 {
      color: white;
      margin-top: 0;
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .calculator {
        padding: 20px;
      }

      .troop-grid {
        grid-template-columns: 1fr;
      }

      .summary-grid {
        grid-template-columns: 1fr;
      }

      .input-with-button {
        flex-direction: column;
        gap: 10px;
      }

      .copy-button {
        align-self: flex-start;
      }
    }
  </style>
</head>
<body>

  <div class="calculator">
    <h1>üéñÔ∏è Military Force Calculator</h1>

    <div class="section">
      <div class="remaining-display" id="remainingDisplay" aria-live="polite">
        Available for distribution: 6,462,500 troops
        <button id="editAvailableBtn" style="background: #6b7280; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 10px;">Edit</button>
      </div>
    </div>

    <div class="section">
      <h3>Force Distribution</h3>

      <div class="troop-grid">
        <div class="troop-card">
          <div class="troop-header">
            <h4>ü™ñ Army</h4>
          </div>
          <div class="input-group">
            <label for="armyPercentage">Percentage:</label>
            <input type="number" id="armyPercentage" value="40" min="0" max="100" inputmode="numeric" style="width: 100%;" />
          </div>
          <div class="troop-result" id="armyCount">Troop Count: 0</div>
        </div>

        <div class="troop-card">
          <div class="troop-header">
            <h4>‚öì Marines</h4>
          </div>
          <div class="input-group">
            <label for="marinesPercentage">Percentage:</label>
            <input type="number" id="marinesPercentage" value="30" min="0" max="100" inputmode="numeric" style="width: 100%;" />
          </div>
          <div class="troop-result" id="marinesCount">Troop Count: 0</div>
        </div>

        <div class="troop-card">
          <div class="troop-header">
            <h4>‚úàÔ∏è Air Force</h4>
          </div>
          <div class="input-group">
            <label for="airforcePercentage">Percentage:</label>
            <input type="number" id="airforcePercentage" value="30" min="0" max="100" inputmode="numeric" style="width: 100%;" />
          </div>
          <div class="troop-result" id="airforceCount">Troop Count: 0</div>
        </div>
      </div>

      <div class="percentage-status" id="percentageTotal" aria-live="polite">
        Total: 100%
      </div>
    </div>

    <div class="section">
      <h3>Enemy Force Distribution</h3>
      <p style="color: #ccc; margin-bottom: 15px;">Enter scout report data to analyze enemy force composition:</p>
      
      <div class="troop-grid">
        <div class="troop-card">
          <div class="troop-header">
            <h4>ü™ñ Enemy Army</h4>
    </div>
    <div class="input-group">
            <label for="enemyArmyCount">Troop Count:</label>
            <input type="number" id="enemyArmyCount" value="0" min="0" inputmode="numeric" style="width: 100%;" />
      </div>
          <div class="troop-result" id="enemyArmyPercent">Percentage: 0%</div>
    </div>

        <div class="troop-card">
          <div class="troop-header">
            <h4>‚öì Enemy Marines</h4>
          </div>
          <div class="input-group">
            <label for="enemyMarinesCount">Troop Count:</label>
            <input type="number" id="enemyMarinesCount" value="0" min="0" inputmode="numeric" style="width: 100%;" />
          </div>
          <div class="troop-result" id="enemyMarinesPercent">Percentage: 0%</div>
    </div>

        <div class="troop-card">
        <div class="troop-header">
            <h4>‚úàÔ∏è Enemy Air Force</h4>
        </div>
          <div class="input-group">
            <label for="enemyAirforceCount">Troop Count:</label>
            <input type="number" id="enemyAirforceCount" value="0" min="0" inputmode="numeric" style="width: 100%;" />
        </div>
          <div class="troop-result" id="enemyAirforcePercent">Percentage: 0%</div>
        </div>
      </div>

      <div class="summary">
            <h3>Enemy Summary</h3>
        <div class="summary-grid">
          <div class="summary-row">
            <span>Total Enemy Troops:</span>
            <span id="enemyTotalTroops">0</span>
        </div>
          <div class="summary-row">
            <span>Enemy Deployment:</span>
            <span id="enemyDeployment">0</span>
        </div>
        </div>
      </div>

      <div style="text-align: center; margin-top: 20px;">
             <button id="counterAttackBtn" style="background: #ef4444; color: white; border: none; padding: 15px 25px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: background 0.3s;">
               Generate Counter Strategy
             </button>
        <div id="counterResults" style="margin-top: 15px; padding: 15px; background: #1e3a8a; border: 1px solid #3b82f6; border-radius: 8px; display: none;"></div>
      </div>
    </div>

    <div class="summary">
      <h3>Summary</h3>
      <div class="summary-grid">
        <div class="summary-row">
          <span>Distributed:</span>
          <span id="totalDeployed">0</span>
        </div>
        <div class="summary-row">
          <span>Army:</span>
          <span id="armySummary">0</span>
        </div>
        <div class="summary-row">
          <span>Marines:</span>
          <span id="marinesSummary">0</span>
        </div>
        <div class="summary-row">
          <span>Air Force:</span>
          <span id="airforceSummary">0</span>
        </div>
        <div class="summary-row">
          <span>Remainder:</span>
          <span id="remainingSummary">6,462,500</span>
        </div>
      </div>
    </div>

    <div class="section">
      <button onclick="goToBattleResults()" style="background: #ef4444; color: white; border: none; padding: 15px 25px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: background 0.3s;">
        Record Battle Results
      </button>
    </div>

  </div>

  <script>
    const MAX_TROOPS = 6462500;
    const BRANCHES = [
      { key: "army", label: "Army" },
      { key: "marines", label: "Marines" },
      { key: "airforce", label: "Air Force" },
    ];

    // Base power values for each unit type
    const BASES = {
      army: 100,
      marines: 100,
      airforce: 100
    };

    // Combat matrix for 3:1 matchup advantages
    const COMBAT_MATRIX = {
      army: { army: 1, marines: 3, airforce: 1/3 },
      marines: { army: 1/3, marines: 1, airforce: 3 },
      airforce: { army: 3, marines: 1/3, airforce: 1 }
    };

    const els = {
      remainingDisplay: document.getElementById("remainingDisplay"),
      percentageTotal: document.getElementById("percentageTotal"),
      totalDeployed: document.getElementById("totalDeployed"),
      remainingSummary: document.getElementById("remainingSummary"),
    };

    function clamp(n, min, max) { return Math.min(max, Math.max(min, n)); }
    function readInt(id, def = 0) {
      const v = document.getElementById(id).value.trim();
      const num = Number(v);
      return Number.isFinite(num) ? Math.trunc(num) : def;
    }

    // Core safe math helpers
    /** Safe division: returns 0 if denom ~ 0 */
    const safeDiv = (num, den) => (Math.abs(den) > 1e-12 ? num / den : 0);

    /** Safe finite: coerce non-finite/NaN to 0 */
    const finite = (x) => (Number.isFinite(x) ? x : 0);

    /** Clamp percent sliders to [-50, 50] just in case */
    const clampPct = (p) => clamp(toFloat(p), -50, 50);

    /** Safe total troops: non-negative int within cap */
    const toTroops = (v) => clamp(toCount(v), 0, MAX_TROOPS);

    /** Safe float conversion */
    const toFloat = (x) => {
      const num = parseFloat(x);
      return Number.isFinite(num) ? num : 0;
    };

    /** Safe count conversion */
    const toCount = (x) => {
      const num = parseInt(x);
      return Number.isFinite(num) ? Math.max(0, Math.floor(num)) : 0;
    };

    // Harden perUnitPower against odd boosts
    function perUnitPower(troop, boosts) {
      const base = BASES[troop] || 100;

      // clamp boosts to reasonable UI bounds
      const a = clampPct(boosts?.attack);
      const h = clampPct(boosts?.health);
      const d = clampPct(boosts?.defense);

      const atk = finite(base * (1 + a / 100));
      const hp  = finite(base * (1 + h / 100));
      const def = finite(base * (1 + d / 100));

      // avoid tiny negative due to FP: max with 0
      const effectivePower = finite((atk * hp * def) / (base * base));
      return {
        atk: Math.max(0, atk),
        hp: Math.max(0, hp),
        def: Math.max(0, def),
        effectivePower: Math.max(0, effectivePower),
      };
    }

    // Available troops management
    let availableTroops = MAX_TROOPS;

    function getAvailableTroops() {
      return availableTroops;
    }

    function setAvailableTroops(troops) {
      availableTroops = clamp(troops, 0, MAX_TROOPS);
    }

    function showEditAvailableModal() {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 1000; display: flex;
        align-items: center; justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="background: #1a1a2e; padding: 30px; border-radius: 15px; border: 1px solid #333; max-width: 400px; width: 90%;">
          <h3 style="color: #64b5f6; margin-top: 0; text-align: center;">Edit Available Troops</h3>
          
          <div style="margin: 20px 0;">
            <label style="color: #ccc; display: block; margin-bottom: 8px;">Available Troops:</label>
            <input type="number" id="editAvailableInput" value="${availableTroops}" min="0" max="${MAX_TROOPS}" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #555; background: #2a2a3e; color: white; text-align: center; font-size: 16px;">
            <p style="color: #999; font-size: 0.85em; margin: 8px 0 0 0;">Maximum: ${MAX_TROOPS.toLocaleString()} troops</p>
      </div>
          
          <div style="text-align: center;">
            <button id="cancelEditAvailable" style="background: #6b7280; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-right: 10px;">Cancel</button>
            <button id="applyEditAvailable" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">Apply</button>
      </div>
    </div>
      `;
      
      document.body.appendChild(modal);
      
      // Add event listeners
      document.getElementById('cancelEditAvailable').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      document.getElementById('applyEditAvailable').addEventListener('click', () => {
        const newTroops = parseInt(document.getElementById('editAvailableInput').value) || 0;
        setAvailableTroops(newTroops);
        updateCalculations();
        document.body.removeChild(modal);
      });
    }

    function getBranchState() {
      return BRANCHES.map(b => {
        const active = document.getElementById(b.key + "Toggle").checked;
        const pct = active ? clamp(readInt(b.key + "Percentage"), 0, 100) : 0;
        return { ...b, active, pct };
      });
    }

    function normalizePercentages(states) {
      // Normalize active branch percentages to total 100 (largest-remainder method)
      const active = states.filter(s => s.active);
      const sum = active.reduce((a, s) => a + s.pct, 0);

      if (active.length === 0) return states;

      if (sum === 100) return states;

      if (sum === 0) {
        const equal = Math.floor(100 / active.length);
        let remainder = 100 - equal * active.length;
        active.forEach(s => (s.pct = equal));
        for (let i = 0; i < active.length && remainder > 0; i++, remainder--) {
          active[i].pct += 1;
        }
        return states;
      }

      const scaled = [];
      let accum = 0;
      active.forEach(s => {
        const exact = (s.pct * 100) / sum;
        const floored = Math.floor(exact);
        scaled.push({ s, exact, floored, frac: exact - floored });
        s.pct = floored;
        accum += floored;
      });

      let leftover = 100 - accum;
      scaled.sort((a, b) => b.frac - a.frac);
      for (let i = 0; i < scaled.length && leftover > 0; i++, leftover--) {
        scaled[i].s.pct += 1;
      }
      return states;
    }

    function preciseAllocate(total, states) {
      // Allocate troop counts exactly to total using largest remainder
      const active = states.filter(s => s.active);
      const shares = active.map(s => {
        const exact = (total * s.pct) / 100;
        const floored = Math.floor(exact);
        return { s, exact, floored, frac: exact - floored };
      });

      let assigned = shares.reduce((a, x) => a + x.floored, 0);
      let remainder = total - assigned;

      shares.sort((a, b) => b.frac - a.frac);
      for (let i = 0; i < shares.length && remainder > 0; i++, remainder--) {
        shares[i].floored += 1;
      }

      const map = new Map();
      shares.forEach(x => map.set(x.s.key, x.floored));
      states.forEach(s => { if (!map.has(s.key)) map.set(s.key, 0); });
      return map;
    }

    function updateCardStates(states) {
      states.forEach(({ key, active }) => {
        const percentageInput = document.getElementById(key + "Percentage");
        percentageInput.disabled = !active;
      });
    }

    function updateCalculations({ autoNormalize = true } = {}) {
      // Use the current available troops (can be edited)
      const remainingTroops = getAvailableTroops();

      els.remainingDisplay.innerHTML =
        `Available for distribution: ${remainingTroops.toLocaleString()} troops <button id="editAvailableBtn" style="background: #6b7280; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-left: 10px;">Edit</button>`;

      // Get current percentages with validation
      const armyPct = clamp(readInt("armyPercentage", 0), 0, 100);
      const marinesPct = clamp(readInt("marinesPercentage", 0), 0, 100);
      const airforcePct = clamp(readInt("airforcePercentage", 0), 0, 100);
      const totalPct = armyPct + marinesPct + airforcePct;

      // Validate percentage inputs
      if (armyPct < 0 || marinesPct < 0 || airforcePct < 0) {
        showToast('Percentages cannot be negative', 'error');
        return;
      }

      // Status UI with better feedback
      if (totalPct === 100) {
        els.percentageTotal.textContent = `Total: ${totalPct}% ‚úÖ`;
        els.percentageTotal.className = "percentage-status percentage-valid";
      } else if (totalPct > 100) {
        els.percentageTotal.textContent = `Total: ${totalPct}% ‚ö†Ô∏è (exceeds 100%)`;
        els.percentageTotal.className = "percentage-status percentage-invalid";
        showToast('Total percentages exceed 100%', 'error');
      } else {
        els.percentageTotal.textContent = `Total: ${totalPct}% (${100 - totalPct}% unassigned)`;
        els.percentageTotal.className = "percentage-status percentage-invalid";
      }

      // Calculate troop counts from percentages with proper rounding
      const armyCount = totalPct > 0 ? Math.round((armyPct / totalPct) * remainingTroops * (totalPct / 100)) : 0;
      const marinesCount = totalPct > 0 ? Math.round((marinesPct / totalPct) * remainingTroops * (totalPct / 100)) : 0;
      const airforceCount = totalPct > 0 ? Math.round((airforcePct / totalPct) * remainingTroops * (totalPct / 100)) : 0;
      
      const distributed = armyCount + marinesCount + airforceCount;
      const unassigned = remainingTroops - distributed;

      // Update troop count displays with click-to-copy functionality
      document.getElementById("armyCount").textContent = `Troop Count: ${armyCount.toLocaleString()}`;
      document.getElementById("marinesCount").textContent = `Troop Count: ${marinesCount.toLocaleString()}`;
      document.getElementById("airforceCount").textContent = `Troop Count: ${airforceCount.toLocaleString()}`;

      // Make troop counts clickable for copying
      ['army', 'marines', 'airforce'].forEach(type => {
        const element = document.getElementById(type + "Count");
        element.style.cursor = 'pointer';
        element.title = 'Click to copy';
        element.onclick = () => copyTroopCount(type);
      });

      // Summary with validation feedback
      els.totalDeployed.textContent = distributed.toLocaleString();
      document.getElementById("armySummary").textContent = armyCount.toLocaleString();
      document.getElementById("marinesSummary").textContent = marinesCount.toLocaleString();
      document.getElementById("airforceSummary").textContent = airforceCount.toLocaleString();
      els.remainingSummary.textContent = unassigned.toLocaleString();
      
      // Save calculator data for battle results integration
      const calculatorData = {
        army: armyCount,
        marines: marinesCount,
        airforce: airforceCount,
        armyPercentage: armyPct,
        marinesPercentage: marinesPct,
        airforcePercentage: airforcePct,
        availableTroops: remainingTroops,
        totalDeployed: distributed,
        remainingTroops: unassigned,
        timestamp: Date.now()
      };
      
      localStorage.setItem('lastCalculatorData', JSON.stringify(calculatorData));
    }

    async function copyTroopCount(type) {
      const element = document.getElementById(type + "Count");
      const count = element.textContent.replace(/[^\d,]/g, '').replace(/,/g, '');
      const typeName = type.charAt(0).toUpperCase() + type.slice(1);
      const text = `${typeName}: ${parseInt(count).toLocaleString()}`;
      
      try {
        await navigator.clipboard.writeText(text);
        const originalText = element.textContent;
        element.textContent = "Copied!";
        element.style.background = "#10b981";
        setTimeout(() => {
          element.textContent = originalText;
          element.style.background = "";
        }, 1500);
      } catch (err) {
        showToast('Failed to copy to clipboard', 'error');
      }
    }

    function autoAdjustPercentages() {
      const states = getBranchState();
      const active = states.filter(s => s.active);
      if (active.length === 1) {
        states.forEach(s => s.pct = s.active ? 100 : 0);
        states.forEach(s => document.getElementById(s.key + "Percentage").value = s.pct);
      }
    }

    async function writeClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (e) {
        // Fallback for non-secure contexts
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.setAttribute("readonly", "");
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand("copy");
        document.body.removeChild(ta);
        return ok;
      }
    }

    async function copyTroopCount(branch) {
      const toggle = document.getElementById(branch + "Toggle");
      if (!toggle.checked) return;

      // Ensure latest calc
      updateCalculations();

      const resultText = document.getElementById(branch + "Result").textContent;
      const text = `${({army:"Army", marines:"Marines", airforce:"Air Force"})[branch]}: ${resultText.replace(" troops","")}`;

      const ok = await writeClipboard(text);
      const el = document.getElementById(branch + "Result");
      const original = el.textContent;
      el.classList.add("copied");
      el.textContent = ok ? "Copied!" : "Copy failed";
      setTimeout(() => { el.classList.remove("copied"); el.textContent = original; }, 1500);
    }

    // Copy functionality removed - no longer needed

    // Battle Results Navigation
    function goToBattleResults() {
      // Save current calculator data to localStorage with more details
      const calculatorData = {
        army: parseInt(document.getElementById("armyResult").textContent.replace(/[^\d]/g, '')) || 0,
        marines: parseInt(document.getElementById("marinesResult").textContent.replace(/[^\d]/g, '')) || 0,
        airforce: parseInt(document.getElementById("airforceResult").textContent.replace(/[^\d]/g, '')) || 0,
        // Additional calculator context
        armyPercentage: parseInt(document.getElementById("armyPercentage").value) || 0,
        marinesPercentage: parseInt(document.getElementById("marinesPercentage").value) || 0,
        airforcePercentage: parseInt(document.getElementById("airforcePercentage").value) || 0,
        availableTroops: getAvailableTroops(),
        timestamp: Date.now()
      };
      
      localStorage.setItem('lastCalculatorData', JSON.stringify(calculatorData));
      
      // Navigate to battle results page
      window.location.href = 'battle_results.html';
    }

    // Event listeners
    BRANCHES.forEach(({ key }) => {
      document.getElementById(key + "Percentage").addEventListener("input", () => {
        updateCalculations();
      });
    });

    // Add event listener for edit available troops button
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'editAvailableBtn') {
        showEditAvailableModal();
      }
    });


    // Enemy Force Distribution Functions
    function setupEnemyForceDistribution() {
      const enemyInputs = ['enemyArmyCount', 'enemyMarinesCount', 'enemyAirforceCount'];
      
      console.log('Setting up enemy force distribution...');
      
      enemyInputs.forEach(id => {
        const input = document.getElementById(id);
        console.log(`Looking for element: ${id}`, input);
        if (input) {
          input.addEventListener('input', calculateEnemyDistribution);
          input.addEventListener('change', calculateEnemyDistribution);
          console.log(`Added event listeners to ${id}`);
        } else {
          console.log(`Element ${id} not found!`);
        }
      });
      
      const counterBtn = document.getElementById('counterAttackBtn');
      console.log('Counter button:', counterBtn);
      if (counterBtn) {
        counterBtn.addEventListener('click', generateCounterStrategy);
        console.log('Added click listener to counter button');
      }
      
      // Initial calculation
      calculateEnemyDistribution();
    }

    function calculateEnemyDistribution() {
      // Get input values directly
      const armyInput = document.getElementById('enemyArmyCount');
      const marinesInput = document.getElementById('enemyMarinesCount');
      const airforceInput = document.getElementById('enemyAirforceCount');
      
      if (!armyInput || !marinesInput || !airforceInput) {
        console.log('Enemy input elements not found');
        return;
      }
      
      const armyCount = parseInt(armyInput.value) || 0;
      const marinesCount = parseInt(marinesInput.value) || 0;
      const airforceCount = parseInt(airforceInput.value) || 0;
      
      const total = armyCount + marinesCount + airforceCount;
      
      console.log('Enemy counts:', { armyCount, marinesCount, airforceCount, total });
      
      // Calculate percentages
      const armyPercent = total > 0 ? Math.round((armyCount / total) * 100) : 0;
      const marinesPercent = total > 0 ? Math.round((marinesCount / total) * 100) : 0;
      const airforcePercent = total > 0 ? Math.round((airforceCount / total) * 100) : 0;
      
      // Update percentage displays
      const armyPercentEl = document.getElementById('enemyArmyPercent');
      const marinesPercentEl = document.getElementById('enemyMarinesPercent');
      const airforcePercentEl = document.getElementById('enemyAirforcePercent');
      
      if (armyPercentEl) armyPercentEl.textContent = `Percentage: ${armyPercent}%`;
      if (marinesPercentEl) marinesPercentEl.textContent = `Percentage: ${marinesPercent}%`;
      if (airforcePercentEl) airforcePercentEl.textContent = `Percentage: ${airforcePercent}%`;
      
      // Update summary
      const totalTroopsEl = document.getElementById('enemyTotalTroops');
      const deploymentEl = document.getElementById('enemyDeployment');
      
      if (totalTroopsEl) totalTroopsEl.textContent = total.toLocaleString();
      if (deploymentEl) deploymentEl.textContent = total.toLocaleString();
    }

    function analyzeBattleHistory(battleHistory, enemyArmyPercent, enemyMarinesPercent, enemyAirforcePercent) {
      if (!battleHistory || battleHistory.length === 0) {
        return null;
      }

      // Find battles with similar enemy compositions (within 10% tolerance)
      const similarBattles = battleHistory.filter(battle => {
        if (!battle.enemyTroops) return false;
        
        const totalEnemy = battle.enemyTroops.army + battle.enemyTroops.marines + battle.enemyTroops.airforce;
        if (totalEnemy === 0) return false;
        
        const battleArmyPercent = (battle.enemyTroops.army / totalEnemy) * 100;
        const battleMarinesPercent = (battle.enemyTroops.marines / totalEnemy) * 100;
        const battleAirforcePercent = (battle.enemyTroops.airforce / totalEnemy) * 100;
        
        const armyDiff = Math.abs(battleArmyPercent - enemyArmyPercent);
        const marinesDiff = Math.abs(battleMarinesPercent - enemyMarinesPercent);
        const airforceDiff = Math.abs(battleAirforcePercent - enemyAirforcePercent);
        
        return armyDiff <= 10 && marinesDiff <= 10 && airforceDiff <= 10;
      });

      if (similarBattles.length === 0) {
        return null;
      }

      // Analyze successful strategies (victories with low loss rates)
      const successfulBattles = similarBattles.filter(battle => {
        if (battle.outcome !== 'victory') return false;
        
        const totalSent = battle.troopsSent.army + battle.troopsSent.marines + battle.troopsSent.airforce;
        const totalLost = battle.troopsLost.army + battle.troopsLost.marines + battle.troopsLost.airforce;
        const lossRate = totalSent > 0 ? (totalLost / totalSent) * 100 : 100;
        
        return lossRate <= 20; // Low loss rate indicates good strategy
      });

      if (successfulBattles.length === 0) {
        return null;
      }

      // Calculate average successful troop distribution
      let totalArmyPercent = 0;
      let totalMarinesPercent = 0;
      let totalAirforcePercent = 0;

      successfulBattles.forEach(battle => {
        const totalSent = battle.troopsSent.army + battle.troopsSent.marines + battle.troopsSent.airforce;
        if (totalSent > 0) {
          totalArmyPercent += (battle.troopsSent.army / totalSent) * 100;
          totalMarinesPercent += (battle.troopsSent.marines / totalSent) * 100;
          totalAirforcePercent += (battle.troopsSent.airforce / totalSent) * 100;
        }
      });

      const avgArmy = Math.round(totalArmyPercent / successfulBattles.length);
      const avgMarines = Math.round(totalMarinesPercent / successfulBattles.length);
      const avgAirforce = Math.round(totalAirforcePercent / successfulBattles.length);

      // Normalize to 100%
      const total = avgArmy + avgMarines + avgAirforce;
      if (total !== 100) {
        const diff = 100 - total;
        if (avgAirforce >= avgArmy && avgAirforce >= avgMarines) {
          return { army: avgArmy, marines: avgMarines, airforce: avgAirforce + diff };
        } else if (avgArmy >= avgMarines) {
          return { army: avgArmy + diff, marines: avgMarines, airforce: avgAirforce };
        } else {
          return { army: avgArmy, marines: avgMarines + diff, airforce: avgAirforce };
        }
      }

      return { army: avgArmy, marines: avgMarines, airforce: avgAirforce };
    }

    // Harden summarizeSide
    function summarizeSide(input) {
      const types = ["army", "marines", "airforce"];
      const powers = {};
      let totalCount = 0;

      for (const t of types) {
        const b = input?.[t] || {};
        const count = toTroops(b.count);
        powers[t] = perUnitPower(t, b);
        totalCount += count;
      }
      return { powers, totalCount };
    }

    // Harden computeBattleTotals
    function computeBattleTotals(p1, p2) {
      const types = ["army", "marines", "airforce"];
      const p1Sum = summarizeSide(p1);
      const p2Sum = summarizeSide(p2);

      let p1TotalPower = 0;
      let p2TotalPower = 0;

      for (const t1 of types) {
        for (const t2 of types) {
          const c1 = toTroops(p1?.[t1]?.count);
          const c2 = toTroops(p2?.[t2]?.count);
          if (c1 <= 0 || c2 <= 0) continue;

          const eff1 = finite(COMBAT_MATRIX[t1]?.[t2]) || 1;
          const eff2 = finite(COMBAT_MATRIX[t2]?.[t1]) || 1;

          p1TotalPower += finite(p1Sum.powers[t1].effectivePower * c1 * eff1);
          p2TotalPower += finite(p2Sum.powers[t2].effectivePower * c2 * eff2);
        }
      }

      p1TotalPower = Math.max(0, p1TotalPower);
      p2TotalPower = Math.max(0, p2TotalPower);

      const totalCombatPower = p1TotalPower + p2TotalPower;
      if (totalCombatPower <= 0) {
        return {
          p1TotalPower: 0,
          p2TotalPower: 0,
          p1Advantage: 0.5,
          p2Advantage: 0.5,
          powerRatio: 1,
          inversePowerRatio: 1,
          p1TotalCount: p1Sum.totalCount,
          p2TotalCount: p2Sum.totalCount,
        };
      }

      const p1Advantage = safeDiv(p1TotalPower, totalCombatPower);
      const p2Advantage = 1 - p1Advantage;

      const powerRatio = p2TotalPower > 0 ? safeDiv(p1TotalPower, p2TotalPower) : 1;
      const inversePowerRatio = p1TotalPower > 0 ? safeDiv(p2TotalPower, p1TotalPower) : 1;

      return {
        p1TotalPower, p2TotalPower,
        p1Advantage, p2Advantage,
        powerRatio, inversePowerRatio,
        p1TotalCount: p1Sum.totalCount,
        p2TotalCount: p2Sum.totalCount,
      };
    }

    // Harden computeCasualties
    function computeCasualties(p1, p2, totals) {
      const types = ["army", "marines", "airforce"];
      const { p1Advantage, p2Advantage, powerRatio, inversePowerRatio } = totals;

      // clamp helper
      const clampRate = (r) => clamp(finite(r), 0, 0.95);

      let p1CasualtyRate, p2CasualtyRate;

      if (powerRatio > 10) {
        p1CasualtyRate = clampRate(0.1 * inversePowerRatio);
        p2CasualtyRate = clampRate(0.4 + powerRatio * 0.02);
      } else if (inversePowerRatio > 10) {
        p2CasualtyRate = clampRate(0.1 * powerRatio);
        p1CasualtyRate = clampRate(0.4 + inversePowerRatio * 0.02);
      } else if (powerRatio > 3) {
        p1CasualtyRate = clampRate(0.2 * inversePowerRatio);
        p2CasualtyRate = clampRate(0.3 + powerRatio * 0.05);
      } else if (inversePowerRatio > 3) {
        p2CasualtyRate = clampRate(0.2 * powerRatio);
        p1CasualtyRate = clampRate(0.3 + inversePowerRatio * 0.05);
      } else {
        p1CasualtyRate = clampRate((1 - p1Advantage) * 0.9);
        p2CasualtyRate = clampRate((1 - p2Advantage) * 0.9);
      }

      const p1Casualties = { army: 0, marines: 0, airforce: 0 };
      const p2Casualties = { army: 0, marines: 0, airforce: 0 };

      for (const t of types) {
        const c1 = toTroops(p1?.[t]?.count);
        const c2 = toTroops(p2?.[t]?.count);
        p1Casualties[t] = Math.min(c1, Math.floor(c1 * p1CasualtyRate));
        p2Casualties[t] = Math.min(c2, Math.floor(c2 * p2CasualtyRate));
      }

      const p1Total = p1Casualties.army + p1Casualties.marines + p1Casualties.airforce;
      const p2Total = p2Casualties.army + p2Casualties.marines + p2Casualties.airforce;

      return {
        p1Casualties, p2Casualties,
        p1Total, p2Total,
        p1CasualtyRate, p2CasualtyRate,
      };
    }

    /** Advisor: compute weights from enemy threats; size to any total (default MAX_TROOPS)
     *  Control-point realistic: applies 3:1 matchup multipliers to weights (mirrors battle matrix).
     */
    function computeCounterAdvice(enemy, friendlyTotal = MAX_TROOPS) {
      const types = ["army", "marines", "airforce"];
      const enemyPower = summarizeSide(enemy).powers;

      const threats = {
        army:     toTroops(enemy?.army?.count)     * enemyPower.army.effectivePower,
        marines:  toTroops(enemy?.marines?.count)  * enemyPower.marines.effectivePower,
        airforce: toTroops(enemy?.airforce?.count) * enemyPower.airforce.effectivePower,
      };

      const weights = {
        marines:  finite(threats.airforce) * 3, // counter Air
        airforce: finite(threats.army)     * 3, // counter Army
        army:     finite(threats.marines)  * 3, // counter Marines
      };

      const sumW = finite(weights.army + weights.marines + weights.airforce);

      const exactPct = sumW > 0 ? {
        army:     (weights.army     / sumW) * 100,
        marines:  (weights.marines  / sumW) * 100,
        airforce: (weights.airforce / sumW) * 100,
      } : { army: 100/3, marines: 100/3, airforce: 100/3 };

      const rounded = {
        army:     Math.floor(finite(exactPct.army)),
        marines:  Math.floor(finite(exactPct.marines)),
        airforce: Math.floor(finite(exactPct.airforce)),
      };

      let remainder = 100 - (rounded.army + rounded.marines + rounded.airforce);
      if (remainder > 0) {
        const order = Object.entries(weights).sort((a, b) => b[1] - a[1]).map(([k]) => k);
        let i = 0;
        while (remainder-- > 0 && order.length) {
          rounded[order[i % order.length]] += 1;
          i++;
        }
      }

      const total = toTroops(friendlyTotal);
      const counts = {
        army:     Math.floor((rounded.army     / 100) * total),
        marines:  Math.floor((rounded.marines  / 100) * total),
        airforce: Math.floor((rounded.airforce / 100) * total),
      };

      const allocated = counts.army + counts.marines + counts.airforce;
      const troopRemainder = total - allocated;
      if (troopRemainder > 0) {
        const top = Object.entries(weights).sort((a, b) => b[1] - a[1])[0]?.[0] || "army";
        counts[top] += troopRemainder;
      }

      return { percentages: rounded, counts, threats, weights, total };
    }

    // DOM adapter safety
    function readForm(playerNum) {
      const p = `p${playerNum}`;
      const val = (id) => document.getElementById(id)?.value;

      return {
        army:     { count: toTroops(val(`${p}-army`)),
                    attack: clampPct(val(`${p}-army-attack`)),
                    health: clampPct(val(`${p}-army-health`)),
                    defense: clampPct(val(`${p}-army-defense`)) },
        marines:  { count: toTroops(val(`${p}-marines`)),
                    attack: clampPct(val(`${p}-marines-attack`)),
                    health: clampPct(val(`${p}-marines-health`)),
                    defense: clampPct(val(`${p}-marines-defense`)) },
        airforce: { count: toTroops(val(`${p}-airforce`)),
                    attack: clampPct(val(`${p}-airforce-attack`)),
                    health: clampPct(val(`${p}-airforce-health`)),
                    defense: clampPct(val(`${p}-airforce-defense`)) },
      };
    }

    // Safe DOM setter
    const set = (id, txt) => {
      const el = document.getElementById(id);
      if (el) el.textContent = String(txt);
    };

    // Event wiring guard
    function wireUI() {
      try {
        // Initialize inputs safely
        const initInputs = () => {
          const inputs = ['enemyArmyCount', 'enemyMarinesCount', 'enemyAirforceCount'];
          inputs.forEach(id => {
            const input = document.getElementById(id);
            if (input) {
              input.addEventListener('input', calculateEnemyDistribution);
              input.addEventListener('change', calculateEnemyDistribution);
            }
          });
        };
        initInputs();
      } catch (e) {
        console.warn('Error initializing inputs:', e);
      }

      // Battle simulation button
      const commence = document.getElementById('commence');
      commence?.addEventListener('click', () => {
        try {
          const p1 = readForm(1);
          const p2 = readForm(2);
          const totals = computeBattleTotals(p1, p2);
          const casualties = computeCasualties(p1, p2, totals);
          
          // Update UI with safe setters
          set('p1-power', Math.round(totals.p1TotalPower).toLocaleString());
          set('p2-power', Math.round(totals.p2TotalPower).toLocaleString());
          set('p1-advantage', Math.round(totals.p1Advantage * 100) + '%');
          set('p2-advantage', Math.round(totals.p2Advantage * 100) + '%');
          set('p1-casualties', casualties.p1Total.toLocaleString());
          set('p2-casualties', casualties.p2Total.toLocaleString());
        } catch (e) {
          console.error('Error in battle simulation:', e);
        }
      });

      // Counter strategy buttons
      const p1Btn = document.getElementById('p1-counter-btn');
      p1Btn?.addEventListener('click', () => {
        try {
          const enemy = readForm(2);
          const total = toTroops(document.getElementById('p1-army')?.value) +
                       toTroops(document.getElementById('p1-marines')?.value) +
                       toTroops(document.getElementById('p1-airforce')?.value) || MAX_TROOPS;
          const advice = computeCounterAdvice(enemy, total);
          const box = document.getElementById('p1-counter-strategy');
          if (box) {
            box.textContent = 
              `Recommended: Army ${advice.counts.army.toLocaleString()} (${advice.percentages.army}%), ` +
              `Marines ${advice.counts.marines.toLocaleString()} (${advice.percentages.marines}%), ` +
              `Air ${advice.counts.airforce.toLocaleString()} (${advice.percentages.airforce}%).`;
          }
        } catch (e) {
          console.error('Error in P1 counter strategy:', e);
        }
      });

      const p2Btn = document.getElementById('p2-counter-btn');
      p2Btn?.addEventListener('click', () => {
        try {
          const enemy = readForm(1);
          const total = toTroops(document.getElementById('p2-army')?.value) +
                       toTroops(document.getElementById('p2-marines')?.value) +
                       toTroops(document.getElementById('p2-airforce')?.value) || MAX_TROOPS;
          const advice = computeCounterAdvice(enemy, total);
          const box = document.getElementById('p2-counter-strategy');
          if (box) {
            box.textContent = 
              `Recommended: Army ${advice.counts.army.toLocaleString()} (${advice.percentages.army}%), ` +
              `Marines ${advice.counts.marines.toLocaleString()} (${advice.percentages.marines}%), ` +
              `Air ${advice.counts.airforce.toLocaleString()} (${advice.percentages.airforce}%).`;
          }
        } catch (e) {
          console.error('Error in P2 counter strategy:', e);
        }
      });
    }

    function generateCounterStrategy() {
      const armyInput = document.getElementById('enemyArmyCount');
      const marinesInput = document.getElementById('enemyMarinesCount');
      const airforceInput = document.getElementById('enemyAirforceCount');
      
      const armyCount = parseInt(armyInput?.value) || 0;
      const marinesCount = parseInt(marinesInput?.value) || 0;
      const airforceCount = parseInt(airforceInput?.value) || 0;
      
      const total = armyCount + marinesCount + airforceCount;
      
      if (total === 0) {
        alert('Please enter enemy troop counts first.');
        return;
      }
      
      const resultsEl = document.getElementById('counterResults');
      if (!resultsEl) return;
      
      // Calculate enemy percentages
      const armyPercent = total > 0 ? (armyCount / total) * 100 : 0;
      const marinesPercent = total > 0 ? (marinesCount / total) * 100 : 0;
      const airforcePercent = total > 0 ? (airforceCount / total) * 100 : 0;
      
      // Get battle history for learning
      const battleHistory = JSON.parse(localStorage.getItem('battleHistory') || '[]');
      const learnedStrategy = analyzeBattleHistory(battleHistory, armyPercent, marinesPercent, airforcePercent);
      
      let strategies = [];
      
      // Enemy Army is strong vs Commandos and Navy but weak vs Air Force
      if (armyPercent > 30) {
        strategies.push({
          type: 'Air Force',
          reason: `Enemy has strong Army (${Math.round(armyPercent)}%) - Air Force is effective against Army`,
          recommendation: 'Deploy Air Force units to counter enemy Army strength'
        });
      }
      
      // Enemy Marines is strong vs Air Force and Navy but weak vs Army
      if (marinesPercent > 30) {
        strategies.push({
          type: 'Army',
          reason: `Enemy has strong Marines (${Math.round(marinesPercent)}%) - Army is effective against Marines`,
          recommendation: 'Deploy Army units to counter enemy Marine strength'
        });
      }
      
      // Enemy Air Force is strong vs Army and Navy but weak vs Commandos (Marines)
      if (airforcePercent > 30) {
        strategies.push({
          type: 'Marines',
          reason: `Enemy has strong Air Force (${Math.round(airforcePercent)}%) - Marines are effective against Air Force`,
          recommendation: 'Deploy Marine units to counter enemy Air Force strength'
        });
      }
      
      // Use the new computeCounterAdvice function with 3:1 matchup multipliers
      const enemy = {
        army: { count: armyCount },
        marines: { count: marinesCount },
        airforce: { count: airforceCount }
      };
      
      // Get available troops for sizing (use control-point pool if available)
      const availableTroops = getAvailableTroops();
      const advice = computeCounterAdvice(enemy, availableTroops);
      
      // Use custom strategy if available, otherwise use the new advice
      let recommendedArmy, recommendedMarines, recommendedAirforce;
      if (customStrategy) {
        recommendedArmy = customStrategy.army;
        recommendedMarines = customStrategy.marines;
        recommendedAirforce = customStrategy.airforce;
      } else if (learnedStrategy) {
        // Use learned strategy from battle history
        recommendedArmy = learnedStrategy.army;
        recommendedMarines = learnedStrategy.marines;
        recommendedAirforce = learnedStrategy.airforce;
      } else {
        // Use the new matrix-aware advice
        recommendedArmy = advice.percentages.army;
        recommendedMarines = advice.percentages.marines;
        recommendedAirforce = advice.percentages.airforce;
      }
      
      // Generate counter strategy HTML
      let html = '<h4 style="color: #64b5f6; margin-top: 0;">Recommended Counter-Attack Force Distribution</h4>';
      
      html += '<div style="background: #374151; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #10b981;">';
      html += '<h5 style="color: #10b981; margin-top: 0;">Your Recommended Troop Percentages:</h5>';
      html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin: 10px 0;">`;
      html += `<div style="text-align: center; padding: 8px; background: #1f2937; border-radius: 5px;">`;
      html += `<div style="color: #ff4d4d; font-weight: bold;">ü™ñ Army</div>`;
      html += `<div style="font-size: 18px; font-weight: bold; color: #fff;">${recommendedArmy}%</div>`;
      html += `</div>`;
      html += `<div style="text-align: center; padding: 8px; background: #1f2937; border-radius: 5px;">`;
      html += `<div style="color: #4da6ff; font-weight: bold;">‚öì Marines</div>`;
      html += `<div style="font-size: 18px; font-weight: bold; color: #fff;">${recommendedMarines}%</div>`;
      html += `</div>`;
      html += `<div style="text-align: center; padding: 8px; background: #1f2937; border-radius: 5px;">`;
      html += `<div style="color: #33cc33; font-weight: bold;">‚úàÔ∏è Air Force</div>`;
      html += `<div style="font-size: 18px; font-weight: bold; color: #fff;">${recommendedAirforce}%</div>`;
      html += `</div>`;
      html += `</div>`;
      
      // Add explanation of the new 3:1 matchup system if using the new advice
      if (!customStrategy && !learnedStrategy) {
        html += '<div style="margin-top: 15px; padding: 10px; background: #1f2937; border-radius: 5px; border-left: 3px solid #64b5f6;">';
        html += '<h6 style="color: #64b5f6; margin: 0 0 8px 0; font-size: 14px;">Smart Counter Strategy (3:1 Matchup Advantage)</h6>';
        html += '<p style="color: #ccc; margin: 0; font-size: 12px; line-height: 1.4;">';
        html += 'This recommendation uses the actual battle matrix: Marines counter Air Force (3:1), Air Force counters Army (3:1), Army counters Marines (3:1). ';
        html += 'The system analyzes enemy threats and recommends the optimal counter-mix based on your available troops.';
        html += '</p>';
        html += '</div>';
      }
      
      html += '</div>';
      
      // Determine primary strategy (highest percentage)
      let primaryStrategy = null;
      if (recommendedArmy >= recommendedMarines && recommendedArmy >= recommendedAirforce) {
        primaryStrategy = { type: 'Army', percentage: recommendedArmy, color: '#ff4d4d' };
      } else if (recommendedMarines >= recommendedAirforce) {
        primaryStrategy = { type: 'Marines', percentage: recommendedMarines, color: '#4da6ff' };
      } else {
        primaryStrategy = { type: 'Air Force', percentage: recommendedAirforce, color: '#33cc33' };
      }
      
      // Add strategy explanation
      html += '<div style="background: #374151; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #3b82f6;">';
      html += '<h5 style="color: #64b5f6; margin-top: 0;">Strategy Rationale:</h5>';
      
      // Add learning indicator if using battle history
      if (learnedStrategy) {
        html += '<div style="background: #065f46; padding: 8px; margin: 8px 0; border-radius: 5px; border-left: 3px solid #10b981;">';
        html += '<span style="color: #10b981; font-weight: bold;">üß† AI Learning:</span> ';
        html += '<span style="color: #d1fae5;">This strategy is based on analysis of your previous successful battles against similar enemy compositions.</span>';
        html += '</div>';
      }
      
      if (strategies.length > 0) {
        // Find the strategy that matches our primary recommendation
        const matchingStrategy = strategies.find(s => s.type === primaryStrategy.type);
        if (matchingStrategy) {
          html += `<div style="margin: 8px 0; padding: 8px; background: #1f2937; border-radius: 5px; border-left: 3px solid ${primaryStrategy.color};">`;
          html += `<strong style="color: ${primaryStrategy.color};">Primary Counter: ${primaryStrategy.type} (${primaryStrategy.percentage}%)</strong><br>`;
          html += `${matchingStrategy.reason}<br>`;
          html += `<em style="color: #ccc;">${matchingStrategy.recommendation}</em>`;
          html += '</div>';
        }
        
        // Add secondary considerations if there are other strong enemy types
        const otherStrategies = strategies.filter(s => s.type !== primaryStrategy.type);
        if (otherStrategies.length > 0) {
          html += '<div style="margin: 8px 0; padding: 8px; background: #1f2937; border-radius: 5px;">';
          html += '<strong style="color: #64b5f6;">Secondary Considerations:</strong><br>';
          otherStrategies.forEach(strategy => {
            html += `‚Ä¢ ${strategy.reason}<br>`;
          });
          html += '</div>';
      }
    } else {
        html += '<div style="margin: 8px 0; padding: 8px; background: #1f2937; border-radius: 5px;">';
        html += '<strong style="color: #64b5f6;">Balanced Approach:</strong> Enemy force is relatively balanced. Using a mixed approach to maintain flexibility and avoid being countered.';
        html += '</div>';
      }
      
      html += '</div>';
      
      // Add action buttons
      html += '<div style="margin-top: 20px; text-align: center;">';
      html += '<button id="editStrategyBtn" style="background: #6b7280; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; margin-right: 10px;">Edit Strategy</button>';
      html += '<button id="useForForceBtn" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold;">üìã Use for Force Distribution</button>';
      html += '</div>';
      
      // Add battle history insights if available
      if (learnedStrategy) {
        const battleHistory = JSON.parse(localStorage.getItem('battleHistory') || '[]');
        const similarBattles = battleHistory.filter(battle => {
          if (!battle.enemyTroops) return false;
          const totalEnemy = battle.enemyTroops.army + battle.enemyTroops.marines + battle.enemyTroops.airforce;
          if (totalEnemy === 0) return false;
          const battleArmyPercent = (battle.enemyTroops.army / totalEnemy) * 100;
          const battleMarinesPercent = (battle.enemyTroops.marines / totalEnemy) * 100;
          const battleAirforcePercent = (battle.enemyTroops.airforce / totalEnemy) * 100;
          const armyDiff = Math.abs(battleArmyPercent - armyPercent);
          const marinesDiff = Math.abs(battleMarinesPercent - marinesPercent);
          const airforceDiff = Math.abs(battleAirforcePercent - airforcePercent);
          return armyDiff <= 10 && marinesDiff <= 10 && airforceDiff <= 10;
        });
        
        const successfulBattles = similarBattles.filter(battle => {
          if (battle.outcome !== 'victory') return false;
          const totalSent = battle.troopsSent.army + battle.troopsSent.marines + battle.troopsSent.airforce;
          const totalLost = battle.troopsLost.army + battle.troopsLost.marines + battle.troopsLost.airforce;
          const lossRate = totalSent > 0 ? (totalLost / totalSent) * 100 : 100;
          return lossRate <= 20;
        });
        
        if (similarBattles.length > 0) {
          html += '<div style="background: #1f2937; padding: 12px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #10b981;">';
          html += '<h6 style="color: #10b981; margin-top: 0;">üìä Battle History Analysis:</h6>';
          html += `<div style="color: #d1fae5; font-size: 0.9em;">`;
          html += `‚Ä¢ Found ${similarBattles.length} similar battles in your history<br>`;
          html += `‚Ä¢ ${successfulBattles.length} were successful (victory with ‚â§20% losses)<br>`;
          html += `‚Ä¢ Average loss rate in successful battles: ${successfulBattles.length > 0 ? 
            (successfulBattles.reduce((sum, battle) => {
              const totalSent = battle.troopsSent.army + battle.troopsSent.marines + battle.troopsSent.airforce;
              const totalLost = battle.troopsLost.army + battle.troopsLost.marines + battle.troopsLost.airforce;
              return sum + (totalSent > 0 ? (totalLost / totalSent) * 100 : 0);
            }, 0) / successfulBattles.length).toFixed(1) : '0'}%`;
          html += `</div></div>`;
        }
      }
      
      resultsEl.innerHTML = html;
      resultsEl.style.display = 'block';
      
      // Add event listeners for the new buttons
      const editBtn = document.getElementById('editStrategyBtn');
      const useBtn = document.getElementById('useForForceBtn');
      
      if (editBtn) {
        editBtn.addEventListener('click', () => {
          showEditStrategyModal(recommendedArmy, recommendedMarines, recommendedAirforce);
        });
      }
      
      if (useBtn) {
        useBtn.addEventListener('click', () => {
          // Copy percentages to Force Distribution section
          document.getElementById('armyPercentage').value = recommendedArmy;
          document.getElementById('marinesPercentage').value = recommendedMarines;
          document.getElementById('airforcePercentage').value = recommendedAirforce;
          
          // Update calculations with new percentages
          updateCalculations();
          
          // Show success message
          useBtn.style.background = '#059669';
          useBtn.textContent = '‚úÖ Applied!';
          setTimeout(() => {
            useBtn.style.background = '#10b981';
            useBtn.textContent = 'üìã Use for Force Distribution';
          }, 2000);
        });
      }
    }

    // Custom Strategy Management
    let customStrategy = null;

    function showEditStrategyModal(army, marines, airforce) {
      // Create modal overlay
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 1000; display: flex;
        align-items: center; justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="background: #1a1a2e; padding: 30px; border-radius: 15px; border: 1px solid #333; max-width: 500px; width: 90%;">
          <h3 style="color: #64b5f6; margin-top: 0; text-align: center;">Edit Counter Strategy</h3>
          
          <div style="margin: 20px 0;">
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
              <div style="text-align: center;">
                <label style="color: #ff4d4d; font-weight: bold; display: block; margin-bottom: 8px;">ü™ñ Army</label>
                <input type="number" id="editArmy" value="${army}" min="0" max="100" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #555; background: #2a2a3e; color: white; text-align: center;">
              </div>
              <div style="text-align: center;">
                <label style="color: #4da6ff; font-weight: bold; display: block; margin-bottom: 8px;">‚öì Marines</label>
                <input type="number" id="editMarines" value="${marines}" min="0" max="100" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #555; background: #2a2a3e; color: white; text-align: center;">
              </div>
              <div style="text-align: center;">
                <label style="color: #33cc33; font-weight: bold; display: block; margin-bottom: 8px;">‚úàÔ∏è Air Force</label>
                <input type="number" id="editAirforce" value="${airforce}" min="0" max="100" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #555; background: #2a2a3e; color: white; text-align: center;">
              </div>
            </div>
            
            <div style="background: #374151; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="saveStrategy" style="margin-right: 10px;">
                <span style="color: #ccc;">üíæ Save this strategy as my default counter strategy</span>
              </label>
              <p style="color: #999; font-size: 0.85em; margin: 8px 0 0 0;">This will apply this strategy logic to all future enemy analyses</p>
            </div>
          </div>
          
          <div style="text-align: center;">
            <button id="cancelEdit" style="background: #6b7280; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-right: 10px;">Cancel</button>
            <button id="applyEdit" style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">Apply Strategy</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Add event listeners
      document.getElementById('cancelEdit').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      document.getElementById('applyEdit').addEventListener('click', () => {
        const newArmy = parseInt(document.getElementById('editArmy').value) || 0;
        const newMarines = parseInt(document.getElementById('editMarines').value) || 0;
        const newAirforce = parseInt(document.getElementById('editAirforce').value) || 0;
        const saveStrategy = document.getElementById('saveStrategy').checked;
        
        // Validate percentages sum to 100
        const total = newArmy + newMarines + newAirforce;
        if (total !== 100) {
          alert('Percentages must sum to exactly 100%');
          return;
        }
        
        // Save custom strategy if requested
        if (saveStrategy) {
          customStrategy = {
            army: newArmy,
            marines: newMarines,
            airforce: newAirforce,
            name: 'Custom Strategy'
          };
          localStorage.setItem('customCounterStrategy', JSON.stringify(customStrategy));
          alert('‚úÖ Custom strategy saved! This will be used for all future counter strategies.');
        }
        
        // Apply to Force Distribution
        document.getElementById('armyPercentage').value = newArmy;
        document.getElementById('marinesPercentage').value = newMarines;
        document.getElementById('airforcePercentage').value = newAirforce;
        
        // Auto-calculate troop counts based on new percentages
        updateCalculations();
        
        // Close modal
        document.body.removeChild(modal);
        
        // Show success message
        const resultsEl = document.getElementById('counterResults');
        if (resultsEl) {
          resultsEl.innerHTML = `
            <div style="text-align: center; padding: 20px;">
              <h4 style="color: #10b981; margin-top: 0;">‚úÖ Strategy Applied!</h4>
              <p style="color: #ccc;">Custom strategy has been applied to Force Distribution</p>
              ${saveStrategy ? '<p style="color: #64b5f6;">üíæ Strategy saved for future use</p>' : ''}
            </div>
          `;
        }
      });
      
      // Auto-calculate total as user types
      ['editArmy', 'editMarines', 'editAirforce'].forEach(id => {
        document.getElementById(id).addEventListener('input', () => {
          const army = parseInt(document.getElementById('editArmy').value) || 0;
          const marines = parseInt(document.getElementById('editMarines').value) || 0;
          const airforce = parseInt(document.getElementById('editAirforce').value) || 0;
          const total = army + marines + airforce;
          
          const applyBtn = document.getElementById('applyEdit');
          if (total === 100) {
            applyBtn.style.background = '#10b981';
            applyBtn.textContent = 'Apply Strategy';
          } else {
            applyBtn.style.background = '#ef4444';
            applyBtn.textContent = `Apply Strategy (${total}%)`;
          }
        });
      });
    }

    // Load custom strategy on page load
    function loadCustomStrategy() {
      const saved = localStorage.getItem('customCounterStrategy');
      if (saved) {
        customStrategy = JSON.parse(saved);
        console.log('Loaded custom strategy:', customStrategy);
      }
    }




    // First render
    updateCalculations();
    loadCustomStrategy();
    
    // Setup enemy force distribution and auto-calculate troop counts after DOM is ready
    setTimeout(() => {
      setupEnemyForceDistribution();
      autoCalculateTroopCounts();
    }, 100);
    
    // Also try again after a longer delay to ensure DOM is fully ready
    setTimeout(() => {
      console.log('Second attempt at auto-calculating troop counts...');
      autoCalculateTroopCounts();
    }, 500);
    
    // Ensure we run after DOM is completely loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM fully loaded, running auto-calculate...');
        wireUI(); // Initialize safe event wiring
        autoCalculateTroopCounts();
        setupBattleDataListener();
      });
    } else {
      // DOM is already loaded
      console.log('DOM already loaded, running auto-calculate immediately...');
      wireUI(); // Initialize safe event wiring
      autoCalculateTroopCounts();
      setupBattleDataListener();
    }
    
    // Listen for new battle data updates
    function setupBattleDataListener() {
      // Listen for custom events from battle results page
      window.addEventListener('battleDataUpdated', function(event) {
        const battleData = event.detail;
        console.log('New battle data received:', battleData);
        
        // Check if current enemy composition matches the new battle
        const armyCount = parseInt(document.getElementById('enemyArmyCount')?.value) || 0;
        const marinesCount = parseInt(document.getElementById('enemyMarinesCount')?.value) || 0;
        const airforceCount = parseInt(document.getElementById('enemyAirforceCount')?.value) || 0;
        
        if (armyCount > 0 || marinesCount > 0 || airforceCount > 0) {
          // Auto-update counter strategy if enemy data is present
          setTimeout(() => {
            generateCounterStrategy();
            showUpdateNotification(battleData);
          }, 1000);
        }
      });
      
      // Check for pending updates on page load
      checkForPendingUpdates();
    }
    
    function checkForPendingUpdates() {
      const updateData = localStorage.getItem('counterStrategyUpdateNeeded');
      if (updateData) {
        try {
          const update = JSON.parse(updateData);
          const timeSinceUpdate = Date.now() - update.timestamp;
          
          // If update is recent (within last 5 minutes), show notification
          if (timeSinceUpdate < 5 * 60 * 1000) {
            showUpdateNotification(update);
          }
          
          // Clear the update flag
          localStorage.removeItem('counterStrategyUpdateNeeded');
        } catch (error) {
          console.error('Error parsing update data:', error);
          localStorage.removeItem('counterStrategyUpdateNeeded');
        }
      }
    }
    
    function showUpdateNotification(battleData) {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4caf50;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 1000;
        max-width: 300px;
        font-size: 14px;
        animation: slideIn 0.3s ease-out;
      `;
      
      const lossRate = battleData.lossRate || calculateLossRate(battleData);
      const outcome = battleData.outcome || 'unknown';
      const outcomeIcon = outcome === 'victory' ? 'üéâ' : outcome === 'defeat' ? 'üí•' : '‚öîÔ∏è';
      
      notification.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 20px;">${outcomeIcon}</span>
          <div>
            <div style="font-weight: bold;">Counter Strategy Updated!</div>
            <div style="font-size: 12px; opacity: 0.9;">
              New battle data: ${outcome} (${lossRate.toFixed(1)}% loss rate)
            </div>
          </div>
          <button onclick="this.parentElement.parentElement.remove()" style="
            background: none; border: none; color: white; font-size: 18px; 
            cursor: pointer; padding: 0; margin-left: 10px;
          ">√ó</button>
        </div>
      `;
      
      // Add CSS animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, 5000);
    }
    
    function calculateLossRate(battle) {
      if (battle.troopsSent && battle.troopsLost) {
        const totalSent = battle.troopsSent.army + battle.troopsSent.marines + battle.troopsSent.airforce;
        const totalLost = battle.troopsLost.army + battle.troopsLost.marines + battle.troopsLost.airforce;
        return totalSent > 0 ? (totalLost / totalSent) * 100 : 0;
      }
      return 0;
    }

    // Complete the summarizeSide function that was truncated
    function summarizeSide(input) {
      const types = ["army", "marines", "airforce"];
      const powers = {};
      let totalCount = 0;
      let totalPower = 0;

      for (const t of types) {
        const count = toCount(input[t + "Count"] || 0);
        const boosts = {
          attack: toFloat(input[t + "AttackBoost"] || 0),
          health: toFloat(input[t + "HealthBoost"] || 0),
          defense: toFloat(input[t + "DefenseBoost"] || 0)
        };
        
        const unitPower = perUnitPower(t, boosts);
        const totalTypePower = finite(count * unitPower.effectivePower);
        
        powers[t] = {
          count,
          unitPower: unitPower.effectivePower,
          totalPower: totalTypePower,
          boosts
        };
        
        totalCount += count;
        totalPower += totalTypePower;
      }

      return {
        totalCount,
        totalPower: Math.max(0, totalPower),
        breakdown: powers,
        distribution: totalCount > 0 ? {
          army: (powers.army.count / totalCount * 100).toFixed(1),
          marines: (powers.marines.count / totalCount * 100).toFixed(1),
          airforce: (powers.airforce.count / totalCount * 100).toFixed(1)
        } : { army: "0.0", marines: "0.0", airforce: "0.0" }
      };
    }

    function generateCounterStrategy() {
      console.log('Generating counter strategy...');
      
      // Get enemy composition
      const enemyArmy = toCount(document.getElementById('enemyArmyCount').value);
      const enemyMarines = toCount(document.getElementById('enemyMarinesCount').value);
      const enemyAirforce = toCount(document.getElementById('enemyAirforceCount').value);
      const enemyTotal = enemyArmy + enemyMarines + enemyAirforce;
      
      if (enemyTotal === 0) {
        showToast('Please enter enemy troop counts first', 'error');
        return;
      }
      
      // Calculate enemy percentages
      const enemyArmyPercent = (enemyArmy / enemyTotal) * 100;
      const enemyMarinesPercent = (enemyMarines / enemyTotal) * 100;
      const enemyAirforcePercent = (enemyAirforce / enemyTotal) * 100;
      
      // Get battle history for analysis
      const battleHistory = JSON.parse(localStorage.getItem('battleHistory') || '[]');
      
      // Analyze historical data
      const historicalStrategy = analyzeBattleHistory(battleHistory, enemyArmyPercent, enemyMarinesPercent, enemyAirforcePercent);
      
      // Generate counter strategy based on combat matrix
      const counterStrategy = calculateOptimalCounter(enemyArmyPercent, enemyMarinesPercent, enemyAirforcePercent);
      
      // Display results
      displayCounterResults(counterStrategy, historicalStrategy, enemyTotal);
    }

    function calculateOptimalCounter(enemyArmyPercent, enemyMarinesPercent, enemyAirforcePercent) {
      // Combat effectiveness matrix (3:1 advantage system)
      // Army > Marines > Air Force > Army
      
      let recommendedArmy = 0;
      let recommendedMarines = 0;
      let recommendedAirforce = 0;
      
      // Calculate counter based on enemy composition
      // Army counters Marines (3:1 advantage)
      recommendedArmy += enemyMarinesPercent * 0.4; // Strong counter
      
      // Marines counter Air Force (3:1 advantage)  
      recommendedMarines += enemyAirforcePercent * 0.4; // Strong counter
      
      // Air Force counters Army (3:1 advantage)
      recommendedAirforce += enemyArmyPercent * 0.4; // Strong counter
      
      // Add base distribution to avoid zero values
      const baseDistribution = 20; // 20% minimum for each type
      recommendedArmy += baseDistribution;
      recommendedMarines += baseDistribution;
      recommendedAirforce += baseDistribution;
      
      // Normalize to 100%
      const total = recommendedArmy + recommendedMarines + recommendedAirforce;
      const normalizedArmy = Math.round((recommendedArmy / total) * 100);
      const normalizedMarines = Math.round((recommendedMarines / total) * 100);
      const normalizedAirforce = 100 - normalizedArmy - normalizedMarines; // Ensure exactly 100%
      
      return {
        army: Math.max(10, normalizedArmy), // Minimum 10%
        marines: Math.max(10, normalizedMarines), // Minimum 10%
        airforce: Math.max(10, normalizedAirforce), // Minimum 10%
        confidence: calculateConfidence(enemyArmyPercent, enemyMarinesPercent, enemyAirforcePercent)
      };
    }

    function calculateConfidence(armyPercent, marinesPercent, airforcePercent) {
      // Higher confidence when enemy has clear composition patterns
      const maxPercent = Math.max(armyPercent, marinesPercent, airforcePercent);
      const minPercent = Math.min(armyPercent, marinesPercent, airforcePercent);
      const spread = maxPercent - minPercent;
      
      // More spread = higher confidence in counter strategy
      return Math.min(95, Math.max(60, 60 + (spread * 0.5)));
    }

    function displayCounterResults(counterStrategy, historicalStrategy, enemyTotal) {
      const resultsDiv = document.getElementById('counterResults');
      
      let html = `
        <h4 style="color: #fbbf24; margin-top: 0;">üéØ Recommended Counter Strategy</h4>
        <div style="background: #0f3460; padding: 15px; border-radius: 8px; margin: 10px 0;">
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
            <div style="text-align: center; padding: 10px; background: #1e3a8a; border-radius: 5px;">
              <div style="color: #ff4d4d; font-weight: bold; font-size: 1.2em;">${counterStrategy.army}%</div>
              <div style="color: #ccc; font-size: 0.9em;">ü™ñ Army</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #1e3a8a; border-radius: 5px;">
              <div style="color: #4da6ff; font-weight: bold; font-size: 1.2em;">${counterStrategy.marines}%</div>
              <div style="color: #ccc; font-size: 0.9em;">‚öì Marines</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #1e3a8a; border-radius: 5px;">
              <div style="color: #33cc33; font-weight: bold; font-size: 1.2em;">${counterStrategy.airforce}%</div>
              <div style="color: #ccc; font-size: 0.9em;">‚úàÔ∏è Air Force</div>
            </div>
          </div>
          <div style="text-align: center; color: #10b981; font-weight: bold;">
            Confidence: ${counterStrategy.confidence.toFixed(1)}%
          </div>
        </div>
      `;
      
      // Add historical strategy if available
      if (historicalStrategy) {
        html += `
          <div style="background: #065f46; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #10b981;">
            <h5 style="color: #10b981; margin-top: 0;">üìä Based on Battle History</h5>
            <div style="color: #d1fae5; font-size: 0.9em;">
              Previous successful strategy against similar enemies:
              Army ${historicalStrategy.army}%, Marines ${historicalStrategy.marines}%, Air Force ${historicalStrategy.airforce}%
            </div>
          </div>
        `;
      }
      
      // Add strategy explanation
      html += `
        <div style="background: #1f2937; padding: 15px; border-radius: 8px; margin: 10px 0;">
          <h5 style="color: #64b5f6; margin-top: 0;">üí° Strategy Explanation</h5>
          <div style="color: #d1d5db; font-size: 0.9em; line-height: 1.4;">
            ${getStrategyExplanation(counterStrategy, enemyTotal)}
          </div>
        </div>
      `;
      
      // Add apply button
      html += `
        <div style="text-align: center; margin-top: 15px;">
          <button onclick="applyCounterStrategy(${counterStrategy.army}, ${counterStrategy.marines}, ${counterStrategy.airforce})" 
                  style="background: #10b981; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">
            Apply This Strategy
          </button>
        </div>
      `;
      
      resultsDiv.innerHTML = html;
      resultsDiv.style.display = 'block';
    }

    function getStrategyExplanation(strategy, enemyTotal) {
      const dominant = strategy.army > strategy.marines && strategy.army > strategy.airforce ? 'Army' :
                     strategy.marines > strategy.airforce ? 'Marines' : 'Air Force';
      
      const explanations = {
        'Army': 'Army units excel against Marines with superior firepower and armor.',
        'Marines': 'Marines are highly effective against Air Force units with anti-aircraft capabilities.',
        'Air Force': 'Air Force dominates Army units with superior mobility and range.'
      };
      
      return `This strategy emphasizes ${dominant.toLowerCase()} units. ${explanations[dominant]} Against ${enemyTotal.toLocaleString()} enemy troops, this composition should provide optimal combat effectiveness.`;
    }

    function applyCounterStrategy(army, marines, airforce) {
      // Apply the recommended percentages to the calculator
      document.getElementById('armyPercentage').value = army;
      document.getElementById('marinesPercentage').value = marines;
      document.getElementById('airforcePercentage').value = airforce;
      
      // Update calculations
      updateCalculations();
      
      // Show success message
      showToast('Counter strategy applied to force distribution!', 'success');
      
      // Scroll to top to see the updated distribution
      document.querySelector('.calculator').scrollIntoView({ behavior: 'smooth' });
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      const bgColor = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';
      toast.style.cssText = `
        position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white;
        padding: 12px 20px; border-radius: 8px; z-index: 1000; font-weight: bold;
        animation: slideIn 0.3s ease-out;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => {
        if (document.body.contains(toast)) {
          document.body.removeChild(toast);
        }
      }, 3000);
    }

    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
      updateCalculations();
      setupEnemyForceDistribution();
      checkForPendingUpdates();
      
      // Listen for battle data updates from other pages
      window.addEventListener('battleDataUpdated', function(event) {
        console.log('Battle data updated:', event.detail);
        showUpdateNotification(event.detail);
      });
      
      // Add input validation
      const numberInputs = document.querySelectorAll('input[type="number"]');
      numberInputs.forEach(input => {
        input.addEventListener('input', function() {
          // Prevent negative values
          if (this.value < 0) this.value = 0;
          
          // Validate percentage inputs
          if (this.id.includes('Percentage')) {
            if (this.value > 100) {
              this.value = 100;
              showToast('Percentage cannot exceed 100%', 'error');
            }
          }
        });
      });
    });
</script>
  <script src="../src/scripts/components/shared-nav.js"></script>
</body>
</html>
